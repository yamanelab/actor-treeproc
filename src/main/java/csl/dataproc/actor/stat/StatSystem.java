package csl.dataproc.actor.stat;

import akka.actor.ActorSystem;
import akka.actor.ExtendedActorSystem;
import csl.dataproc.actor.remote.RemoteManager;
import csl.dataproc.tgls.util.JsonReader;
import csl.dataproc.tgls.util.JsonWriter;

import java.io.BufferedReader;
import java.io.Writer;
import java.net.InetAddress;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.security.MessageDigest;
import java.time.*;
import java.util.*;
import java.util.function.BinaryOperator;
import java.util.function.Function;
import java.util.regex.Pattern;
import java.util.stream.Stream;

/**
 * global instance of statistics management system.
 *
 * <pre>
 *     StatSystem s = StatSystem.system();
 *        //At the first time, it creates a new instance and set to {@link #globalInstance}.
 *
 *     s.setEnabled(true); //enables collecting statistics data
 * </pre>
 *  RemoteConfig#createSystem() will do this if the <code>--stat</code> argument is supplied.
 *
 *  <p>
 * In your app code, you can save a sub-class of {@link StatBase} by {@link #saveJsonp(String, StatBase)}.
 * <pre>
 *     StatSystem s = StatSystem.system();
 *     if (s.isEnabled()) {
 *         s.saveJsonp("my-stat-%d.json", statObj)
 *     }
 * </pre>
 * The first parameter is a format with expanding a long ID obtained from {@link StatBase#id}.
 *  The id can be a long number returned by {@link #getId(ActorSystem, String)}.
 *  The file path is determined by {@link #getFile(String, long)}.
 *  e.g. for ID 3_000_001
 * <pre>
 *   dir/n003/n000/my-stat-3000001.json
 * </pre>
 *
 * <p> ID management:
 *   <ul>
 *     <li>{@link #getSystemId(ActorSystem)}, {@link #getSystemIdFromName(String)}:
 *         computed from {@link #getSystemName(ActorSystem)} which will be {@link ExtendedActorSystem}'s host name.
 *         The long value is actually a 16 bit number and total of md5 of the name,
 *         and maintained systemIds map of {@link #globalInstance}.
 *     </li>
 *
 *     <li> {@link #getInstanceId(long)}, {@link #getPathId(String)}:
 *        An instance number started from 1.
 *        The count is currently up to 10^9, about a 29bit number.
 *        The number is generated by the count field of {@link #globalInstance} with updating with synchronization,
 *        and maintained the pathIds map.
 *        </li>
 *
 *     <li>{@link #getId(long, long)}, {@link #getId(ActorSystem, String)}: combine the system id and the instance id. </li>
 *   </ul>
 *
 * <p>
 *     periodic saving:
 *      the interval can be obtained by {@link #getInterval()}.
 *     {@link StatBase#isOver(Duration)} checks its duration: you can define instances for total and periodic files.
 *
 *     <pre>
 *       class MyActor extends AbstractActor {
 *         MyStat total;
 *         MyStat period;
 *         public void preStart() {
 *             StatSystem s = StatSystem.system();
 *             long id = s.getId(context().system(), self().path().toStringWithoutAddress());
 *             total = new MyStat(id);
 *             period = new MyStat(id);
 *         }
 *
 *         ...
 *
 *             total.myCount++;
 *             period.myCount++;
 *             StatSystem s = StatSystem.system();
 *             if (period.isOver(s.getInterval()) {
 *                  s.saveJsonp("total-%d.jsonp", total);
 *                  s.saveJsonp("period-%d.jsonp", period);
 *                  period = new MyStat(period.id);
 *             }
 *       }
 *     </pre>
 */
public class StatSystem {
    protected static StatSystem globalInstance;

    protected boolean enabled;
    protected Map<ActorSystem,Long> systemIds = new IdentityHashMap<>();
    protected Map<String,Long> pathIds = new HashMap<>();
    protected long count = 1;

    protected Path dir;
    protected Duration interval = Duration.ofSeconds(1);

    protected String envelopeComparatorType;

    public static final String PROP_STAT_DIR = "csl.actor.stat.dir";
    public static final long MAX_INSTANCES = 1000_000_000L;

    public static StatSystem system() {
        StatSystem s = globalInstance;
        if (s == null) {
            s = new StatSystem();
        }
        return s;
    }

    public StatSystem() {
        if (globalInstance != null) {
            System.err.println("existing stat: " + globalInstance);
        }
        globalInstance = this;
    }

    public void setEnabled(boolean enabled) {
        this.enabled = enabled;
    }

    public boolean isEnabled() {
        return enabled;
    }

    public synchronized long getId(ActorSystem system, String path) {
        return getId(getSystemId(system), getPathId(path));
    }

    public synchronized long getPathId(String path) {
        return pathIds.computeIfAbsent(path, p -> count++);
    }

    public synchronized long getSystemId(ActorSystem system) {
        return systemIds.computeIfAbsent(system, s -> {
            String name = getSystemName(s);
            long id = getSystemIdFromName(name);
            log("getSystemName: " + system + " -> " + name + " : " + id);
            return id;
        });
    }


    public synchronized void setSystemId(ActorSystem system, long id) {
        log("setSystemId: " + system + " : " + id);
        systemIds.put(system, id);
    }

    public void log(String str) {
        RemoteManager m = RemoteManager.instance;
        if (m != null) {
            m.log(str);
        } else {
            System.err.println("[" + LocalDateTime.now() + "] " + str);
        }
    }

    public String getSystemName(ActorSystem system) {
        if (system instanceof ExtendedActorSystem) {
            try {
                return system.provider().getDefaultAddress().toString();
            } catch (Exception ex) {
                ex.printStackTrace();
                try {
                    return system.name() + "@" + InetAddress.getLocalHost().getHostName();
                } catch (Exception ex2) {
                    ex2.printStackTrace();
                    return system.name();
                }
            }
        } else {
            return system.toString();
        }
    }

    public long getSystemIdFromName(String name) {
        try {
            short bid = 0;
            for (byte b : MessageDigest.getInstance("md5").digest(name.getBytes())) {
                bid ^= (b & 0xFF);
            }
            return getSystemIdFromDigest(bid);
        } catch (Exception ex) {
            throw new RuntimeException(ex);
        }
    }

    public long getSystemIdFromDigest(short bid) {
        return (bid & 0xFFFFL) * MAX_INSTANCES;
    }

    public long getId(long systemId, long instanceId) {
        return systemId + instanceId;
    }

    public long getInstanceId(long id) {
        return id % MAX_INSTANCES;
    }

    public long getSystemId(long id) {
        return id / MAX_INSTANCES;
    }


    /** the method set the dir path to the property {@link #PROP_STAT_DIR}: "csl.actor.stat.dir" */
    public void setDir(Path dir) {
        this.dir = dir;
        System.setProperty(PROP_STAT_DIR, dir.toString());
    }

    public Path getDir() {
        return dir;
    }

    public Path getDir(long id) {
        try {
            if (dir == null) {
                this.dir = Paths.get(System.getProperty(PROP_STAT_DIR, "actor-stat"));
            }
            long n = getInstanceId(id);
            long max = 1000;
            Path p = dir;
            List<String> ps = new ArrayList<>();
            while (n >= max) {
                ps.add(String.format("n%03d", (n % 1000)));
                n /= max;
            }
            Collections.reverse(ps);
            for (String name : ps) {
                p = p.resolve(name);
            }
            Files.createDirectories(p);
            return p;
        } catch (Exception ex) {
            throw new RuntimeException(ex);
        }
    }

    public Path getFile(String format, long id) {
        return getDir(id).resolve(String.format(format, id));
    }



    public <Stat> Stream<Stat> parseJsonp(BufferedReader reader, Function<Object,Stat> constructor) {
        try {
            return reader.lines()
                    .map(JsonReader::v)
                    .map(JsonReader::parseValue)
                    .map(constructor);
        } catch (Exception ex) {
            throw new RuntimeException(ex);
        }
    }

    public void saveJsonp(String nameFormat, StatBase stat) {
        Path file = getFile(nameFormat, stat.id);
        try {
            Object o = stat.toJson();
            Writer w = Files.newBufferedWriter(file,
                    StandardOpenOption.APPEND,
                    StandardOpenOption.CREATE,
                    StandardOpenOption.WRITE);
            JsonWriter jsonWriter = new JsonWriter(w).withNewLines(false);
            jsonWriter.write(o);
            w.write('\n');
            w.close();
        } catch (Exception ex) {
            throw new RuntimeException(ex);
        }
    }

    public Duration getInterval() {
        return interval;
    }

    /** set interval : default is 1s */
    public void setInterval(Duration interval) {
        this.interval = interval;
    }

    public void setEnvelopeComparatorType(String envelopeComparatorType) {
        this.envelopeComparatorType = envelopeComparatorType;
    }

    public String getEnvelopeComparatorType() {
        return envelopeComparatorType;
    }

    public Instant[] timeRangeJsonp(Pattern... targetFilePatterns) {
        return timeRangeJsonp(findFiles(targetFilePatterns));
    }

    public Instant[] timeRangeJsonp(Stream<Path> files) {
        return files.map(this::timeRangeJsonpFile)
                .reduce(timeIdent, timeReducer);
    }

    static Instant[] timeIdent = new Instant[] {Instant.MAX, Instant.MIN};
    static BinaryOperator<Instant[]> timeReducer = (l, r) -> new Instant[] {
            select(true, l[0], r[0]),
            select(false, l[1], r[1])
    };

    protected Instant[] timeRangeJsonpFile(Path f) {
        try (BufferedReader reader = Files.newBufferedReader(f)) {
            return parseJsonp(reader, this::newStatBase)
                    .map(e -> new Instant[]{e.start, e.getEnd()})
                    .reduce(timeIdent, timeReducer);
        } catch (Exception ex) {
            throw new RuntimeException(f.toString(), ex);
        }
    }

    protected StatBase newStatBase(Object json) {
        StatBase b = new StatBase(-1);
        b.setJson(json);
        return b;
    }

    public Stream<Path> findFiles(Pattern... targetFilePatterns) {
        try {
            return Files.walk(getDir())
                    .filter(Files::isRegularFile)
                    .filter(f -> Arrays.stream(targetFilePatterns)
                            .anyMatch(p -> p.matcher(f.getFileName().toString()).matches()));
        } catch (Exception ex) {
            throw new RuntimeException(ex);
        }
    }

    public static Instant select(boolean before, Instant l, Instant r) {
        if (l.isBefore(r)) {
            return before ? l : r;
        } else {
            return before ? r : l;
        }
    }

    public static class StatBase {
        public long id;
        public Instant start;
        public Duration duration;

        /** the class does not define StatBase(Object json) because of super(json) precedes field initialization*/
        public StatBase(long id) {
            this.id = id;
            init();
        }

        protected void init() {
            start = Instant.now();
        }

        public void updateDuration() {
            duration = durationNow();
        }

        public Duration durationNow() {
            return Duration.between(start, Instant.now());
        }

        public Instant getEnd() {
            return duration == null ? Instant.now() : start.plus(duration);
        }

        public boolean isOver(Duration durationMax) {
            if (duration == null) {
                return durationNow().compareTo(durationMax) > 0;
            } else {
                return duration.compareTo(durationMax) > 0;
            }
        }

        public Map<String,Object> toJson() {
            if (duration == null) {
                updateDuration();
            }
            HashMap<String,Object> m = new HashMap<>();
            m.put("id", id);
            m.put("start", LocalDateTime.ofInstant(start, ZoneId.systemDefault()).toString());
            m.put("duration", duration.toString());
            return m;
        }

        @SuppressWarnings("unchecked")
        public void setJson(Object json) {
            Map<String,Object> m = (Map<String,Object>) json;
            id = longValue(m, "id");
            start = instantValue(m, "start");
            duration = durationValue(m, "duration");
        }

        public static long longValue(Map<String,Object> obj, String key) {
            return ((Number) obj.getOrDefault(key, 0)).longValue();
        }

        public static Instant instantValue(Map<String, Object> obj, String key) {
            String s = (String) obj.get(key);
            if (s != null) {
                if (s.endsWith("Z")) {
                    return Instant.parse(s);
                } else {
                    return LocalDateTime.parse(s).atZone(ZoneId.systemDefault()).toInstant();
                }
            } else {
                return Instant.EPOCH;
            }
        }

        public static Duration durationValue(Map<String, Object> obj, String key) {
            String s = (String) obj.get(key);
            if (s != null) {
                return Duration.parse(s);
            } else {
                return Duration.ZERO;
            }
        }
    }

    public <C extends StatBase> C total(Instant[] timeRange, Stream<Path> files, TotalCountReducer<C> r) {
        return files.map(f -> totalFile(timeRange, f, r))
                .reduce(r.getTotal(timeRange), r);
    }

    protected <C extends StatBase> C totalFile(Instant[] timeRange, Path file, TotalCountReducer<C> r) {
        try (BufferedReader reader = Files.newBufferedReader(file)) {

            return parseJsonp(reader, r::create)
                    .reduce(r.getTotal(timeRange), r);

        } catch (Exception ex) {
            throw new RuntimeException(file.toString(), ex);
        }
    }

    public static abstract class TotalCountReducer<C extends StatSystem.StatBase> implements BinaryOperator<C> {
        public abstract C createTotal();

        public C getTotal(Instant[] timeRange) {
            C c = createTotal();
            c.start = timeRange[0];
            c.duration = Duration.between(timeRange[0], timeRange[1]);
            return c;
        }

        public abstract C create(Object json);

        @Override
        public C apply(C r, C next) {
            if (r.id == -1L) {
                r.id = next.id;
            }
            update(r, next);
            Instant e = r.getEnd();
            if (next.start.isBefore(r.start)) {
                r.start = next.start;
            }
            if (next.getEnd().isAfter(e)) {
                r.duration = Duration.between(r.start, e);
            }
            return r;
        }

        public abstract void update(C r, C next);
    }
}
